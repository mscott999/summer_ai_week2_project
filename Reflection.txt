Overall, this project was not too bad. Converting pseudocode into functioning search algorithms was not difficult, as the pseudocode was provided to us. The most difficult part of the project was understanding how to use all of the built-in functions that the pacman code came with. There is no documentation stating that "getSuccessors()" intakes ONLY a location tuple as a parameter, not the entire state tuple that other methods provide you with. Unfamiliarities such as these were solved through trial and error, using the Berkely assignment website as a refrence.
The final product works as intended. Depth-first searches child nodes before searching sibling nodes, and breadth-first searches adjacent nodes prior to child nodes. The auto-grader passes all tests for both search algorithms, except for "depth-first infinite test." After many attemps at solving this test, I was unable to do so. All other tests pass except for this one. Maybe it is intended to fail, for if depth-first search was used in a truly infinite maze, then it is entirely possible that the algorithm will infinitely search a branch of states and its successors, never finding a close-by solution that was part of another branch. This could also be why my breadth-first algorithm passes this test, but depth does not.